"use strict";const a=require("electron"),i=e=>{const r=process.argv.find(t=>t.startsWith(`--${e}=`));return r?r.split("=")[1]:void 0},c={MEMORY_SERVICE_PATH:i("memory-service-path")||process.env.VITE_MEMORY_SERVICE_PATH,MEMORY_CHROMA_PATH:i("memory-chroma-path")||process.env.VITE_MEMORY_CHROMA_PATH,MEMORY_BACKUPS_PATH:i("memory-backups-path")||process.env.VITE_MEMORY_BACKUPS_PATH,CLAUDE_CONFIG_PATH:i("claude-config-path")||process.env.VITE_CLAUDE_CONFIG_PATH};console.log("Preload script starting with:",{ENV:c,processEnv:{VITE_MEMORY_CHROMA_PATH:process.env.VITE_MEMORY_CHROMA_PATH,VITE_MEMORY_BACKUPS_PATH:process.env.VITE_MEMORY_BACKUPS_PATH,VITE_CLAUDE_CONFIG_PATH:process.env.VITE_CLAUDE_CONFIG_PATH,VITE_MEMORY_SERVICE_PATH:process.env.VITE_MEMORY_SERVICE_PATH},argv:process.argv});const s={use_mcp_tool:async({server_name:e,tool_name:r,arguments:t})=>{try{if(console.log(`Calling MCP tool: ${e}/${r}`,{args:t,env:c}),!c.CLAUDE_CONFIG_PATH)throw new Error("Claude config path not available");if(!c.MEMORY_CHROMA_PATH)throw new Error("Memory Chroma DB path not available");const o=await a.ipcRenderer.invoke("mcp:use-tool",{server_name:e,tool_name:r,arguments:t});return console.log("MCP tool call result:",{request:{server_name:e,tool_name:r,args:t},result:o}),o}catch(o){throw console.error(`MCP tool error (${e}/${r}):`,o),new Error(`MCP tool error (${e}/${r}): ${o instanceof Error?o.message:String(o)}`)}}},l={async store_memory(e,r){return console.log("Storing memory:",{content:e,metadata:r}),await s.use_mcp_tool({server_name:"memory",tool_name:"store_memory",arguments:{content:e,metadata:r}})},async retrieve_memory(e,r=5){try{console.log("Retrieving memory using dashboard endpoint:",{query:e,n_results:r});const t=await s.use_mcp_tool({server_name:"memory",tool_name:"dashboard_retrieve_memory",arguments:{query:e,n_results:r}});let o;t&&t.content&&t.content[0]&&t.content[0].text?o=t.content[0].text:typeof t=="string"?o=t:o=JSON.stringify(t);const n=JSON.parse(o);if(n.error)throw new Error(n.error);return{memories:n.memories||[]}}catch(t){throw console.error("Error retrieving memory:",t),t}},async search_by_tag(e){try{console.log("Searching by tags using dashboard endpoint:",e);const r=await s.use_mcp_tool({server_name:"memory",tool_name:"dashboard_search_by_tag",arguments:{tags:e}});let t;r&&r.content&&r.content[0]&&r.content[0].text?t=r.content[0].text:typeof r=="string"?t=r:t=JSON.stringify(r);const o=JSON.parse(t);if(o.error)throw new Error(o.error);return{memories:o.memories||[]}}catch(r){throw console.error("Error searching by tag:",r),r}},async delete_by_tag(e){return console.log("Deleting by tag(s):",e),await s.use_mcp_tool({server_name:"memory",tool_name:"delete_by_tag",arguments:{tag:e}})},async delete_memory(e){try{console.log("Deleting individual memory using dashboard endpoint:",e);const r=await s.use_mcp_tool({server_name:"memory",tool_name:"dashboard_delete_memory",arguments:{memory_id:e}});let t;r&&r.content&&r.content[0]&&r.content[0].text?t=r.content[0].text:typeof r=="string"?t=r:t=JSON.stringify(r);const o=JSON.parse(t);if(o.status==="error")throw new Error(o.message||"Failed to delete memory");return{status:o.status||"success",message:o.message||"Memory deleted successfully"}}catch(r){throw console.error("Error deleting memory:",r),r}},async recall_memory(e,r=5){try{console.log("Recalling memory with time expressions using dashboard endpoint:",{query:e,n_results:r});const t=await s.use_mcp_tool({server_name:"memory",tool_name:"dashboard_recall_memory",arguments:{query:e,n_results:r}});let o;t&&t.content&&t.content[0]&&t.content[0].text?o=t.content[0].text:typeof t=="string"?o=t:o=JSON.stringify(t);const n=JSON.parse(o);if(n.error)throw new Error(n.error);return{memories:n.memories||[]}}catch(t){throw console.error("Error recalling memory:",t),t}},async check_database_health(){try{console.log("Checking database health using dashboard endpoint");const e=await s.use_mcp_tool({server_name:"memory",tool_name:"dashboard_check_health",arguments:{}});let r;e&&e.content&&e.content[0]&&e.content[0].text?r=e.content[0].text:typeof e=="string"?r=e:r=JSON.stringify(e);const t=JSON.parse(r);return{health:t.health||0,avg_query_time:t.avg_query_time||0,status:t.status||"unknown"}}catch(e){throw console.error("Error checking database health:",e),e}},async get_stats(){try{console.log("Getting stats using dashboard endpoint");const e=await s.use_mcp_tool({server_name:"memory",tool_name:"dashboard_get_stats",arguments:{}});let r;e&&e.content&&e.content[0]&&e.content[0].text?r=e.content[0].text:typeof e=="string"?r=e:r=JSON.stringify(e);const t=JSON.parse(r);return t.error?(console.warn("Stats error:",t.error),{total_memories:0,unique_tags:0}):{total_memories:t.total_memories||0,unique_tags:t.unique_tags||0}}catch(e){throw console.error("Error getting stats:",e),e}},async optimize_db(){try{console.log("Optimizing database using dashboard endpoint");const e=await s.use_mcp_tool({server_name:"memory",tool_name:"dashboard_optimize_db",arguments:{}});let r;e&&e.content&&e.content[0]&&e.content[0].text?r=e.content[0].text:typeof e=="string"?r=e:r=JSON.stringify(e);const t=JSON.parse(r);return t.status==="not_implemented"?(console.info("Database optimization not implemented:",t.message),{message:t.message,status:t.status}):t}catch(e){throw console.error("Error optimizing database:",e),e}},async create_backup(){try{console.log("Creating backup using dashboard endpoint");const e=await s.use_mcp_tool({server_name:"memory",tool_name:"dashboard_create_backup",arguments:{}});let r;e&&e.content&&e.content[0]&&e.content[0].text?r=e.content[0].text:typeof e=="string"?r=e:r=JSON.stringify(e);const t=JSON.parse(r);return t.status==="not_implemented"?(console.info("Database backup not implemented:",t.message),{message:t.message,status:t.status}):t}catch(e){throw console.error("Error creating backup:",e),e}}},m=async()=>{try{console.log("=== Testing Memory Service Connection ===");const r=["MEMORY_SERVICE_PATH","MEMORY_CHROMA_PATH","MEMORY_BACKUPS_PATH","CLAUDE_CONFIG_PATH"].filter(o=>!c[o]);if(r.length>0)throw new Error(`Missing required environment variables: ${r.join(", ")}`);const t=await l.check_database_health();return console.log("Memory service health check successful:",t),a.ipcRenderer.send("service-status",{memory:!0}),!0}catch(e){return console.error("Memory service connection test failed:",e),a.ipcRenderer.send("service-error",{service:"memory",error:e instanceof Error?e.message:String(e)}),a.ipcRenderer.send("service-status",{memory:!1}),!1}};m();a.contextBridge.exposeInMainWorld("electronAPI",{memory:l,fs:{readFile:async(e,r)=>{console.log("readFile called with path:",e);try{const t=await a.ipcRenderer.invoke("fs:readFile",{path:e,options:r});return console.log("readFile successful"),t}catch(t){throw console.error("readFile error:",t),t}},exists:async e=>{console.log("exists called with path:",e);try{const r=await a.ipcRenderer.invoke("fs:exists",{path:e});return console.log("exists check result:",r),r}catch(r){return console.error("exists check error:",r),!1}}}});console.log("Preload script finished exposing APIs");
