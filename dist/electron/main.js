"use strict";var L=Object.defineProperty;var K=(a,e,t)=>e in a?L(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t;var b=(a,e,t)=>K(a,typeof e!="symbol"?e+"":e,t);const u=require("electron"),A=require("path"),D=require("fs"),j=require("os"),W=require("crypto"),J=require("http"),G=require("https"),Q=require("url"),Y=require("util"),X=require("child_process");function Z(a){return a&&a.__esModule&&Object.prototype.hasOwnProperty.call(a,"default")?a.default:a}var P={exports:{}};const ee="16.5.0",te={version:ee};var F;function re(){if(F)return P.exports;F=1;const a=D,e=A,t=j,r=W,n=te.version,c=/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;function l(o){const i={};let d=o.toString();d=d.replace(/\r\n?/mg,`
`);let f;for(;(f=c.exec(d))!=null;){const y=f[1];let h=f[2]||"";h=h.trim();const m=h[0];h=h.replace(/^(['"`])([\s\S]*)\1$/mg,"$2"),m==='"'&&(h=h.replace(/\\n/g,`
`),h=h.replace(/\\r/g,"\r")),i[y]=h}return i}function _(o){const i=S(o),d=p.configDotenv({path:i});if(!d.parsed){const m=new Error(`MISSING_DATA: Cannot parse ${i} for an unknown reason`);throw m.code="MISSING_DATA",m}const f=I(o).split(","),y=f.length;let h;for(let m=0;m<y;m++)try{const w=f[m].trim(),M=T(d,w);h=p.decrypt(M.ciphertext,M.key);break}catch(w){if(m+1>=y)throw w}return p.parse(h)}function g(o){console.log(`[dotenv@${n}][WARN] ${o}`)}function v(o){console.log(`[dotenv@${n}][DEBUG] ${o}`)}function I(o){return o&&o.DOTENV_KEY&&o.DOTENV_KEY.length>0?o.DOTENV_KEY:process.env.DOTENV_KEY&&process.env.DOTENV_KEY.length>0?process.env.DOTENV_KEY:""}function T(o,i){let d;try{d=new URL(i)}catch(w){if(w.code==="ERR_INVALID_URL"){const M=new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");throw M.code="INVALID_DOTENV_KEY",M}throw w}const f=d.password;if(!f){const w=new Error("INVALID_DOTENV_KEY: Missing key part");throw w.code="INVALID_DOTENV_KEY",w}const y=d.searchParams.get("environment");if(!y){const w=new Error("INVALID_DOTENV_KEY: Missing environment part");throw w.code="INVALID_DOTENV_KEY",w}const h=`DOTENV_VAULT_${y.toUpperCase()}`,m=o.parsed[h];if(!m){const w=new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${h} in your .env.vault file.`);throw w.code="NOT_FOUND_DOTENV_ENVIRONMENT",w}return{ciphertext:m,key:f}}function S(o){let i=null;if(o&&o.path&&o.path.length>0)if(Array.isArray(o.path))for(const d of o.path)a.existsSync(d)&&(i=d.endsWith(".vault")?d:`${d}.vault`);else i=o.path.endsWith(".vault")?o.path:`${o.path}.vault`;else i=e.resolve(process.cwd(),".env.vault");return a.existsSync(i)?i:null}function O(o){return o[0]==="~"?e.join(t.homedir(),o.slice(1)):o}function N(o){!!(o&&o.debug)&&v("Loading env from encrypted .env.vault");const d=p._parseVault(o);let f=process.env;return o&&o.processEnv!=null&&(f=o.processEnv),p.populate(f,d,o),{parsed:d}}function B(o){const i=e.resolve(process.cwd(),".env");let d="utf8";const f=!!(o&&o.debug);o&&o.encoding?d=o.encoding:f&&v("No encoding is specified. UTF-8 is used by default");let y=[i];if(o&&o.path)if(!Array.isArray(o.path))y=[O(o.path)];else{y=[];for(const M of o.path)y.push(O(M))}let h;const m={};for(const M of y)try{const H=p.parse(a.readFileSync(M,{encoding:d}));p.populate(m,H,o)}catch(H){f&&v(`Failed to load ${M} ${H.message}`),h=H}let w=process.env;return o&&o.processEnv!=null&&(w=o.processEnv),p.populate(w,m,o),h?{parsed:m,error:h}:{parsed:m}}function E(o){if(I(o).length===0)return p.configDotenv(o);const i=S(o);return i?p._configVault(o):(g(`You set DOTENV_KEY but you are missing a .env.vault file at ${i}. Did you forget to build it?`),p.configDotenv(o))}function R(o,i){const d=Buffer.from(i.slice(-64),"hex");let f=Buffer.from(o,"base64");const y=f.subarray(0,12),h=f.subarray(-16);f=f.subarray(12,-16);try{const m=r.createDecipheriv("aes-256-gcm",d,y);return m.setAuthTag(h),`${m.update(f)}${m.final()}`}catch(m){const w=m instanceof RangeError,M=m.message==="Invalid key length",H=m.message==="Unsupported state or unable to authenticate data";if(w||M){const V=new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");throw V.code="INVALID_DOTENV_KEY",V}else if(H){const V=new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");throw V.code="DECRYPTION_FAILED",V}else throw m}}function $(o,i,d={}){const f=!!(d&&d.debug),y=!!(d&&d.override);if(typeof i!="object"){const h=new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");throw h.code="OBJECT_REQUIRED",h}for(const h of Object.keys(i))Object.prototype.hasOwnProperty.call(o,h)?(y===!0&&(o[h]=i[h]),f&&v(y===!0?`"${h}" is already defined and WAS overwritten`:`"${h}" is already defined and was NOT overwritten`)):o[h]=i[h]}const p={configDotenv:B,_configVault:N,_parseVault:_,config:E,decrypt:R,parse:l,populate:$};return P.exports.configDotenv=p.configDotenv,P.exports._configVault=p._configVault,P.exports._parseVault=p._parseVault,P.exports.config=p.config,P.exports.decrypt=p.decrypt,P.exports.parse=p.parse,P.exports.populate=p.populate,P.exports=p,P.exports}var oe=re();const ne=Z(oe);async function ae(a,e=3e4){const t=Date.now();for(;Date.now()-t<e;){try{if(D.existsSync(a)){const r=D.readFileSync(a,"utf-8");if(r.trim())return console.log(`File found: ${a}, content: ${r.trim()}`),r}}catch(r){console.log(`Error reading file ${a}:`,r)}await new Promise(r=>setTimeout(r,500))}throw new Error(`File ${a} not found or empty after ${e}ms`)}async function se(a){return new Promise(e=>{try{const s=(new Q.URL(a).protocol==="https:"?G:J).get(a,n=>{console.log(`Server check: ${a} responded with status ${n.statusCode}`),e(n.statusCode!==void 0&&n.statusCode<500),s.destroy()});s.on("error",n=>{console.log(`Server check error for ${a}:`,n.message),e(!1),s.destroy()}),s.setTimeout(5e3,()=>{console.log(`Server check timeout for ${a}`),e(!1),s.destroy()})}catch(t){console.log(`Server check failed for ${a}:`,t),e(!1)}})}function q(){console.log("Creating window...");const a=process.env.NODE_ENV==="development"?A.join(process.cwd(),"dist/electron/preload.js"):A.join(__dirname,"preload.js");console.log("Preload script path:",a);const e=new u.BrowserWindow({width:1200,height:800,title:"Memory Dashboard",webPreferences:{nodeIntegration:!1,contextIsolation:!0,preload:a,webSecurity:!0,sandbox:!0,webgl:!1,additionalArguments:[`--memory-service-path=${process.env.VITE_MEMORY_SERVICE_PATH}`,`--memory-chroma-path=${process.env.VITE_MEMORY_CHROMA_PATH}`,`--memory-backups-path=${process.env.VITE_MEMORY_BACKUPS_PATH}`,`--claude-config-path=${process.env.VITE_CLAUDE_CONFIG_PATH}`]}});if(console.log("Environment variables:",{VITE_MEMORY_SERVICE_PATH:process.env.VITE_MEMORY_SERVICE_PATH,VITE_MEMORY_CHROMA_PATH:process.env.VITE_MEMORY_CHROMA_PATH,VITE_MEMORY_BACKUPS_PATH:process.env.VITE_MEMORY_BACKUPS_PATH,VITE_CLAUDE_CONFIG_PATH:process.env.VITE_CLAUDE_CONFIG_PATH,MCP_MEMORY_CHROMA_PATH:process.env.MCP_MEMORY_CHROMA_PATH,MCP_MEMORY_BACKUPS_PATH:process.env.MCP_MEMORY_BACKUPS_PATH}),e.webContents.on("did-fail-load",(t,r,s)=>{console.error("Failed to load page:",s),e.reload()}),e.webContents.on("render-process-gone",(t,r)=>{console.error("Render process gone:",r.reason),r.reason==="crashed"&&(e.destroy(),q())}),e.webContents.on("did-finish-load",async()=>{console.log("Window finished loading"),await(async(s=3)=>{for(let n=0;n<s;n++)try{console.log(`Attempt ${n+1} to connect to memory service...`);const c=await e.webContents.executeJavaScript(`
            if (window.electronAPI && window.electronAPI.memory) {
              const health = await window.electronAPI.memory.check_database_health();
              console.log('Memory service health:', health);
              return health;
            } else {
              throw new Error('Memory API not available');
            }
          `);return console.log("Memory service connection successful:",c),!0}catch(c){console.error(`Memory service connection attempt ${n+1} failed:`,c),await new Promise(l=>setTimeout(l,2e3))}return!1})()||(console.error("Failed to connect to memory service after multiple attempts"),e.webContents.send("memory-service-error","Failed to connect to memory service"))}),process.env.NODE_ENV==="development")console.log("Running in development mode"),setTimeout(async()=>{try{const r=A.join(process.cwd(),".vite-port");console.log("Looking for port file at:",r);const n=`http://localhost:${(await ae(r)).trim()}`;if(console.log("Development server URL:",n),!await(async(_=5)=>{for(;_>0;){try{if(console.log(`Attempting to connect to ${n} (${_} retries left)`),await se(n))return console.log("Successfully connected to development server"),!0}catch(g){console.log("Connection attempt failed:",g)}await new Promise(g=>setTimeout(g,1e3)),_--}return!1})())throw new Error("Failed to connect to development server after 5 attempts");console.log("Loading URL in window:",n),await e.loadURL(n)}catch(r){const s=r instanceof Error?r:new Error(String(r));console.error("Development server connection error:",s),e.isDestroyed()||e.webContents.send("dev-server-error",s.message),u.app.quit()}},1e3);else{console.log("Running in production mode");const t=A.join(__dirname,"../index.html");console.log("Loading file:",t),e.loadFile(t)}e.on("closed",()=>{console.log("Window closed"),e.destroy()}),e.webContents.on("before-input-event",(t,r)=>{r.control&&r.shift&&r.key.toLowerCase()==="i"&&e.webContents.toggleDevTools(),r.key==="F12"&&e.webContents.toggleDevTools()})}const k=Y.promisify(X.exec);class ie{constructor(e){b(this,"config");b(this,"containerProcess",null);b(this,"healthCheckInterval",null);b(this,"isShuttingDown",!1);this.config={containerName:"mcp-memory-chromadb",port:8e3,fallbackPort:8001,...e},console.log("üê≥ DockerChromaManager initialized:",this.config)}async isDockerAvailable(){try{return console.log("üîç Checking Docker availability..."),await k("docker --version"),await k("docker info"),console.log("‚úÖ Docker is available and running"),!0}catch(e){return console.log("‚ùå Docker not available:",e instanceof Error?e.message:"Unknown error"),!1}}async isPortAvailable(e){try{const{stdout:t}=await k(`lsof -i :${e}`);return console.log(`‚ö†Ô∏è Port ${e} is in use:`,t.trim()),!1}catch{return console.log(`‚úÖ Port ${e} is available`),!0}}async findAvailablePort(){const e=[this.config.port,this.config.fallbackPort||8001,8002,8003,8004];for(const t of e)if(await this.isPortAvailable(t))return t;throw new Error(`No available ports found. Tried: ${e.join(", ")}`)}async getContainerStatus(){try{const{stdout:e}=await k(`docker ps --filter "name=${this.config.containerName}" --format "{{.ID}},{{.Status}},{{.Ports}}"`);if(!e.trim())return console.log(`üìã Container ${this.config.containerName} is not running`),{running:!1,healthy:!1,port:this.config.port};const[t,r,s]=e.trim().split(","),n=s.match(/0\.0\.0\.0:(\d+)->/),c=n?parseInt(n[1]):this.config.port,l=r.includes("healthy")||!r.includes("unhealthy");return console.log(`‚úÖ Container ${this.config.containerName} is running on port ${c}`),{running:!0,healthy:l,port:c,containerId:t.trim()}}catch(e){return console.log("‚ùå Error checking container status:",e instanceof Error?e.message:"Unknown error"),{running:!1,healthy:!1,port:this.config.port,error:e instanceof Error?e.message:"Unknown error"}}}async cleanupExistingContainer(){try{console.log(`üßπ Cleaning up existing container: ${this.config.containerName}`);try{await k(`docker stop ${this.config.containerName}`),console.log("‚úÖ Container stopped")}catch{console.log("‚ÑπÔ∏è Container was not running or already stopped")}try{await k(`docker rm ${this.config.containerName}`),console.log("‚úÖ Container removed")}catch{console.log("‚ÑπÔ∏è Container was not found or already removed")}}catch(e){console.log("‚ö†Ô∏è Error during cleanup:",e instanceof Error?e.message:"Unknown error")}}validateChromaPath(){try{console.log(`üîç Validating ChromaDB path: ${this.config.chromaPath}`),D.existsSync(this.config.chromaPath)||(console.log("üìÅ ChromaDB directory does not exist, creating..."),D.mkdirSync(this.config.chromaPath,{recursive:!0}));const e=A.join(this.config.chromaPath,".docker-test");return D.writeFileSync(e,"test"),D.unlinkSync(e),console.log("‚úÖ ChromaDB path is valid and writable"),!0}catch(e){return console.error("‚ùå ChromaDB path validation failed:",e),!1}}async startContainer(){try{if(console.log("üöÄ Starting ChromaDB Docker container..."),!await this.isDockerAvailable())throw new Error("Docker is not available. Please install Docker Desktop and ensure it is running.");if(!this.validateChromaPath())throw new Error(`ChromaDB path is not accessible: ${this.config.chromaPath}`);const e=await this.findAvailablePort();e!==this.config.port&&console.log(`‚ö†Ô∏è Using fallback port ${e} instead of ${this.config.port}`),await this.cleanupExistingContainer();const t=["run","-d","--name",this.config.containerName,"-p",`${e}:8000`,"-v",`${this.config.chromaPath}:/chroma/chroma`,"--health-cmd","curl -f http://localhost:8000/api/v1/heartbeat || exit 1","--health-interval","10s","--health-timeout","5s","--health-retries","3","chromadb/chroma"];console.log("üê≥ Docker command:",`docker ${t.join(" ")}`);const{stdout:r}=await k(`docker ${t.join(" ")}`);return console.log(`‚úÖ Container started with ID: ${r.trim()}`),await this.waitForContainerHealthy(e),this.startHealthMonitoring(e),{running:!0,healthy:!0,port:e,containerId:r.trim()}}catch(e){throw console.error("‚ùå Failed to start ChromaDB container:",e),e}}async waitForContainerHealthy(e,t=3e4){console.log(`‚è≥ Waiting for ChromaDB container to be healthy on port ${e}...`);const r=Date.now(),s=2e3;for(;Date.now()-r<t;){try{const{stdout:n}=await k(`docker inspect --format='{{.State.Health.Status}}' ${this.config.containerName}`),c=n.trim();if(c==="healthy"){console.log("‚úÖ Container is healthy and ready");return}console.log(`‚è≥ Container health status: ${c}, waiting...`);try{await k(`curl -f http://localhost:${e}/api/v1/heartbeat`),console.log("‚úÖ ChromaDB API is responding");return}catch{}}catch{console.log("‚è≥ Still waiting for container health check...")}await new Promise(n=>setTimeout(n,s))}throw new Error(`Container failed to become healthy within ${t}ms`)}startHealthMonitoring(e){console.log("üîÑ Starting health monitoring..."),this.healthCheckInterval=setInterval(async()=>{if(!this.isShuttingDown)try{const t=await this.getContainerStatus();(!t.running||!t.healthy)&&(console.warn("‚ö†Ô∏è ChromaDB container is not healthy, attempting restart..."),await this.restartContainer())}catch(t){console.error("‚ùå Health check failed:",t)}},3e4)}async restartContainer(){console.log("üîÑ Restarting ChromaDB container...");try{return await k(`docker restart ${this.config.containerName}`),await this.waitForContainerHealthy(this.config.port),console.log("‚úÖ Container restarted successfully"),await this.getContainerStatus()}catch(e){return console.error("‚ùå Failed to restart container:",e),await this.startContainer()}}async stopContainer(){console.log("üõë Stopping ChromaDB container..."),this.isShuttingDown=!0,this.healthCheckInterval&&(clearInterval(this.healthCheckInterval),this.healthCheckInterval=null);try{await k(`docker stop ${this.config.containerName}`),console.log("‚úÖ Container stopped successfully")}catch(e){console.log("‚ö†Ô∏è Error stopping container:",e instanceof Error?e.message:"Unknown error")}}async getChromaApiUrl(){return`http://localhost:${(await this.getContainerStatus()).port}`}async testConnection(){try{const e=await this.getChromaApiUrl();return await k(`curl -f ${e}/api/v1/heartbeat`),console.log(`‚úÖ ChromaDB API connection successful: ${e}`),!0}catch(e){return console.log("‚ùå ChromaDB API connection failed:",e instanceof Error?e.message:"Unknown error"),!1}}async cleanup(){console.log("üßπ Cleaning up Docker ChromaDB Manager..."),await this.stopContainer()}}class ce{constructor(e){b(this,"config");b(this,"client",null);b(this,"collection",null);b(this,"isInitialized",!1);b(this,"dockerManager",null);b(this,"useDockerMode",!0);b(this,"fallbackToMcp",!1);this.config=e,console.log("DirectChromaHandler initialized with config:",e),this.dockerManager=new ie({chromaPath:e.chromaPath,backupsPath:e.backupsPath,containerName:"mcp-memory-chromadb",port:8e3})}setupIpcHandlers(){console.log("Setting up direct ChromaDB IPC handlers..."),u.ipcMain.handle("direct-chroma:store",async(e,{content:t,metadata:r})=>await this.storeMemory(t,r)),u.ipcMain.handle("direct-chroma:retrieve",async(e,{query:t,n_results:r})=>await this.retrieveMemory(t,r)),u.ipcMain.handle("direct-chroma:search-by-tag",async(e,{tags:t})=>await this.searchByTag(t)),u.ipcMain.handle("direct-chroma:delete-by-tag",async(e,{tag:t})=>await this.deleteByTag(t)),u.ipcMain.handle("direct-chroma:get-stats",async(e,{})=>await this.getStats()),u.ipcMain.handle("direct-chroma:check-health",async(e,{})=>await this.checkHealth()),u.ipcMain.handle("direct-chroma:optimize",async(e,{})=>await this.optimizeDatabase()),u.ipcMain.handle("direct-chroma:backup",async(e,{})=>await this.createBackup()),u.ipcMain.handle("direct-chroma:status",async(e,{})=>await this.getStatusInfo())}async handleDirectRequest(e,t){switch(console.log(`Direct request: ${e}`,t),e){case"direct-chroma:store":return await this.storeMemory(t.content,t.metadata);case"direct-chroma:retrieve":return await this.retrieveMemory(t.query,t.n_results);case"direct-chroma:search-by-tag":return await this.searchByTag(t.tags);case"direct-chroma:delete-by-tag":return await this.deleteByTag(t.tag);case"direct-chroma:get-stats":return await this.getStats();case"direct-chroma:check-health":return await this.checkHealth();case"direct-chroma:optimize":return await this.optimizeDatabase();case"direct-chroma:backup":return await this.createBackup();case"direct-chroma:status":return await this.getStatusInfo();default:throw new Error(`Unknown operation: ${e}`)}}async initializeClient(){if(!this.isInitialized)try{if(console.log("üöÄ Initializing ChromaDB with Docker container..."),!this.dockerManager)throw new Error("Docker manager not initialized");if(!await this.dockerManager.isDockerAvailable())throw console.log("‚ö†Ô∏è Docker not available, falling back to MCP approach"),this.fallbackToMcp=!0,new Error("Docker ChromaDB fallback: Docker not available, using stable MCP service approach");let t=await this.dockerManager.getContainerStatus();if(t.running?console.log(`‚úÖ ChromaDB container already running on port ${t.port}`):(console.log("üê≥ Starting ChromaDB Docker container..."),t=await this.dockerManager.startContainer()),!await this.dockerManager.testConnection())throw new Error("Failed to connect to ChromaDB container");const{ChromaApi:s}=require("chromadb"),n=await this.dockerManager.getChromaApiUrl();console.log(`üîó Connecting to ChromaDB at: ${n}`),this.client=new s({path:n});try{this.collection=await this.client.getCollection({name:"memories"}),console.log("‚úÖ Using existing memories collection")}catch{console.log("üìÅ Creating new memories collection..."),this.collection=await this.client.createCollection({name:"memories",metadata:{description:"MCP Memory Dashboard storage",created:new Date().toISOString()}}),console.log("‚úÖ Memories collection created")}this.isInitialized=!0,console.log("üéâ Direct ChromaDB access initialized successfully!")}catch(e){console.error("‚ùå Direct ChromaDB initialization failed:",e),this.fallbackToMcp=!0;const t=e instanceof Error?e.message:"Unknown error";throw new Error(`üîß Direct ChromaDB Access Failed: ${t}. Falling back to stable MCP service approach. To resolve: ensure Docker Desktop is installed and running, then restart the application.`)}}async storeMemory(e,t){await this.initializeClient();try{const r=`memory_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,s={...t,timestamp:new Date().toISOString(),type:(t==null?void 0:t.type)||"memory"};return await this.collection.add({ids:[r],documents:[e],metadatas:[s]}),console.log(`‚úÖ Memory stored successfully: ${r}`),{success:!0,id:r,content_hash:r,message:"Memory stored successfully"}}catch(r){throw console.error("‚ùå Error storing memory:",r),new Error(`Failed to store memory: ${r instanceof Error?r.message:"Unknown error"}`)}}async retrieveMemory(e,t=5){await this.initializeClient();try{console.log(`üîç Retrieving memories for query: "${e}" (n=${t})`);const r=await this.collection.query({queryTexts:[e],nResults:t}),s=[];if(r.ids&&r.ids[0])for(let c=0;c<r.ids[0].length;c++){const l={id:r.ids[0][c],content:r.documents[0][c],metadata:r.metadatas[0][c]||{},distance:r.distances?r.distances[0][c]:void 0};s.push(l)}return console.log(`‚úÖ Retrieved ${s.length} memories`),{memories:s,query_text:e,n_results:t}}catch(r){throw console.error("‚ùå Error retrieving memories:",r),new Error(`Failed to retrieve memories: ${r instanceof Error?r.message:"Unknown error"}`)}}async searchByTag(e){await this.initializeClient();try{console.log(`üè∑Ô∏è Searching by tags: ${e.join(", ")}`);const t=await this.collection.get({include:["documents","metadatas"]}),r=[];if(t.ids)for(let n=0;n<t.ids.length;n++){const c=t.metadatas[n]||{},l=c.tags||[];if(e.some(g=>Array.isArray(l)?l.includes(g):typeof l=="string"?l.split(",").map(v=>v.trim()).includes(g):!1)){const g={id:t.ids[n],content:t.documents[n],metadata:c};r.push(g)}}return console.log(`‚úÖ Found ${r.length} memories with matching tags`),{memories:r,search_tags:e}}catch(t){throw console.error("‚ùå Error searching by tags:",t),new Error(`Failed to search by tags: ${t instanceof Error?t.message:"Unknown error"}`)}}async deleteByTag(e){await this.initializeClient();try{console.log(`üóëÔ∏è Deleting memories with tag: ${e}`);const t=await this.collection.get({include:["metadatas"]}),r=[];if(t.ids)for(let n=0;n<t.ids.length;n++){const l=(t.metadatas[n]||{}).tags||[];(Array.isArray(l)?l.includes(e):typeof l=="string"?l.split(",").map(g=>g.trim()).includes(e):!1)&&r.push(t.ids[n])}return r.length>0&&await this.collection.delete({ids:r}),console.log(`‚úÖ Deleted ${r.length} memories with tag: ${e}`),{success:!0,deleted_count:r.length,deleted_ids:r,message:`Successfully deleted ${r.length} memories with tag: ${e}`}}catch(t){throw console.error("‚ùå Error deleting by tag:",t),new Error(`Failed to delete by tag: ${t instanceof Error?t.message:"Unknown error"}`)}}async getStats(){await this.initializeClient();try{console.log("üìä Getting database statistics...");const e=await this.collection.get({include:["metadatas"]}),t=e.ids?e.ids.length:0,r=new Set;if(e.metadatas)for(const c of e.metadatas)c&&c.tags&&(Array.isArray(c.tags)?c.tags:typeof c.tags=="string"?c.tags.split(",").map(_=>_.trim()):[]).forEach(_=>{_&&_.trim()&&r.add(_.trim())});const s=r.size;return console.log(`‚úÖ Stats: ${t} memories, ${s} unique tags`),{total_memories:t,unique_tags:s,collection_name:this.collection.name}}catch(e){return console.error("‚ùå Error getting stats:",e),{total_memories:0,unique_tags:0,collection_name:"unknown"}}}async checkHealth(){try{console.log("üè• Checking database health...");const e=Date.now();await this.initializeClient();const t=await this.collection.get({limit:1}),r=Date.now()-e;return console.log(`‚úÖ Health check passed (${r}ms)`),{health:1,avg_query_time:r,status:"healthy",database_path:this.config.chromaPath,collection_ready:!!this.collection}}catch(e){return console.error("‚ùå Health check failed:",e),{health:0,avg_query_time:0,status:"error",error:e instanceof Error?e.message:"Unknown error"}}}async optimizeDatabase(){await this.initializeClient();try{console.log("‚ö° Optimizing database...");const e=Date.now(),t=await this.getStats(),r=Date.now()-e;return console.log(`‚úÖ Database optimization completed (${r}ms)`),{success:!0,optimization_time_ms:r,memories_count:t.total_memories,unique_tags:t.unique_tags,message:"Database optimization completed successfully",details:{database_path:this.config.chromaPath,collection_name:this.collection.name}}}catch(e){throw console.error("‚ùå Error optimizing database:",e),new Error(`Database optimization failed: ${e instanceof Error?e.message:"Unknown error"}`)}}async createBackup(){await this.initializeClient();try{console.log("üíæ Creating database backup...");const e=Date.now(),r=`backup_${new Date().toISOString().replace(/[:.]/g,"-")}`,s=A.join(this.config.backupsPath,r);D.mkdirSync(s,{recursive:!0});const n=await this.collection.get({include:["documents","metadatas"]}),c={metadata:{created:new Date().toISOString(),source_path:this.config.chromaPath,collection_name:this.collection.name,total_memories:n.ids?n.ids.length:0},memories:[]};if(n.ids)for(let v=0;v<n.ids.length;v++)c.memories.push({id:n.ids[v],content:n.documents[v],metadata:n.metadatas[v]||{}});const l=A.join(s,"memories_backup.json");D.writeFileSync(l,JSON.stringify(c,null,2));const _=Date.now()-e;return console.log(`‚úÖ Backup created successfully: ${r} (${_}ms)`),{success:!0,backup_name:r,backup_path:s,backup_file:l,memories_count:c.memories.length,backup_time_ms:_,message:`Backup created successfully with ${c.memories.length} memories`}}catch(e){throw console.error("‚ùå Error creating backup:",e),new Error(`Backup creation failed: ${e instanceof Error?e.message:"Unknown error"}`)}}async cleanup(){console.log("üßπ Cleaning up DirectChromaHandler..."),this.dockerManager&&await this.dockerManager.cleanup(),this.client=null,this.collection=null,this.isInitialized=!1}isUsingDockerMode(){return this.useDockerMode&&!this.fallbackToMcp}async getStatusInfo(){try{if(this.dockerManager&&!this.fallbackToMcp){const e=await this.dockerManager.getContainerStatus(),t=await this.dockerManager.getChromaApiUrl();return{mode:"docker",docker_available:await this.dockerManager.isDockerAvailable(),container_running:e.running,container_healthy:e.healthy,api_url:t,port:e.port,database_path:this.config.chromaPath}}return{mode:"mcp_fallback",fallback_reason:this.fallbackToMcp?"Docker unavailable or failed":"Not initialized",database_path:this.config.chromaPath}}catch(e){return{mode:"error",error:e instanceof Error?e.message:"Unknown error"}}}}const x=A.join(process.cwd(),".env");console.log("Loading environment variables from:",x);const z=ne.config({path:x});z.error?console.error("Error loading .env file:",z.error):(console.log("Environment variables loaded successfully"),process.env.MCP_MEMORY_CHROMA_PATH=process.env.VITE_MEMORY_CHROMA_PATH,process.env.MCP_MEMORY_BACKUPS_PATH=process.env.VITE_MEMORY_BACKUPS_PATH,console.log("Set MCP environment variables:",{MCP_MEMORY_CHROMA_PATH:process.env.MCP_MEMORY_CHROMA_PATH,MCP_MEMORY_BACKUPS_PATH:process.env.MCP_MEMORY_BACKUPS_PATH}));let C=null;const U=process.env.VITE_USE_DIRECT_CHROMA_ACCESS==="true";console.log("Direct ChromaDB access enabled:",U);if(U){const a=process.env.VITE_MEMORY_CHROMA_PATH||process.env.MCP_MEMORY_CHROMA_PATH,e=process.env.VITE_MEMORY_BACKUPS_PATH||process.env.MCP_MEMORY_BACKUPS_PATH;a&&e?(C=new ce({chromaPath:a,backupsPath:e}),console.log("‚úÖ Initialized Direct ChromaDB Handler - Eliminates MCP service duplication")):console.warn("‚ö†Ô∏è  Direct ChromaDB access requested but paths not configured")}u.app.disableHardwareAcceleration();u.app.commandLine.appendSwitch("disable-software-rasterizer");u.app.commandLine.appendSwitch("disable-gpu");u.app.commandLine.appendSwitch("disable-gpu-compositing");u.app.commandLine.appendSwitch("disable-gpu-sandbox");const le=Y.promisify(D.readFile),he=Y.promisify(D.exists);u.ipcMain.handle("fs:readFile",async(a,{path:e,options:t})=>{try{return console.log("Main process reading file:",e),await le(e,t)}catch(r){throw console.error("Main process readFile error:",r),r}});u.ipcMain.handle("fs:exists",async(a,{path:e})=>{try{return console.log("Main process checking file exists:",e),await he(e)}catch(t){return console.error("Main process exists error:",t),!1}});u.ipcMain.handle("mcp:use-tool",async(a,e)=>{const{server_name:t,tool_name:r,arguments:s}=e;if(console.log(`Handling MCP tool request: ${t}/${r}`,{args:s,useDirectAccess:U}),U&&C&&t==="memory"){console.log("üöÄ Using Direct ChromaDB Access - No MCP service spawning");try{switch(r){case"store_memory":return await C.handleDirectRequest("direct-chroma:store",s);case"dashboard_retrieve_memory":case"retrieve_memory":return await C.handleDirectRequest("direct-chroma:retrieve",s);case"dashboard_search_by_tag":case"search_by_tag":return await C.handleDirectRequest("direct-chroma:search-by-tag",s);case"delete_by_tag":return await C.handleDirectRequest("direct-chroma:delete-by-tag",s);case"dashboard_get_stats":case"get_stats":return await C.handleDirectRequest("direct-chroma:get-stats",s);case"dashboard_check_health":case"check_database_health":return await C.handleDirectRequest("direct-chroma:check-health",s);case"dashboard_optimize_db":case"optimize_db":return await C.handleDirectRequest("direct-chroma:optimize",s);case"dashboard_create_backup":case"create_backup":return await C.handleDirectRequest("direct-chroma:backup",s);default:throw new Error(`Unsupported tool: ${r}`)}}catch(n){console.error("Direct ChromaDB access error, falling back to MCP:",n)}}console.log("‚ö†Ô∏è  Using MCP service spawning approach");try{const n=process.env.VITE_CLAUDE_CONFIG_PATH;if(!n)throw new Error(`VITE_CLAUDE_CONFIG_PATH environment variable not set. Available env vars: ${Object.keys(process.env).filter(I=>I.startsWith("VITE_")).join(", ")}`);console.log("Reading MCP config from:",n);const c=JSON.parse(D.readFileSync(n,"utf-8"));console.log("Available MCP servers:",Object.keys(c.mcpServers));const l=c.mcpServers[t];if(!l)throw new Error(`MCP server "${t}" not found in configuration. Available servers: ${Object.keys(c.mcpServers).join(", ")}`);const{spawn:_}=require("child_process");console.log("Spawning MCP server process:",{command:l.command,args:l.args,cwd:process.env.VITE_MEMORY_SERVICE_PATH,env:Object.keys({...process.env,...l.env})});const g=_(l.command,l.args,{env:{...process.env,...l.env,PYTHONPATH:process.env.VITE_MEMORY_SERVICE_PATH,MCP_MEMORY_CHROMA_PATH:process.env.MCP_MEMORY_CHROMA_PATH||process.env.VITE_MEMORY_CHROMA_PATH,MCP_MEMORY_BACKUPS_PATH:process.env.MCP_MEMORY_BACKUPS_PATH||process.env.VITE_MEMORY_BACKUPS_PATH},cwd:process.env.VITE_MEMORY_SERVICE_PATH,stdio:["pipe","pipe","pipe"]});console.log("MCP server process spawned with:",{pid:g.pid,command:l.command,args:l.args,cwd:process.env.VITE_MEMORY_SERVICE_PATH,env:{PYTHONPATH:process.env.VITE_MEMORY_SERVICE_PATH,MCP_MEMORY_CHROMA_PATH:process.env.MCP_MEMORY_CHROMA_PATH||process.env.VITE_MEMORY_CHROMA_PATH,MCP_MEMORY_BACKUPS_PATH:process.env.MCP_MEMORY_BACKUPS_PATH||process.env.VITE_MEMORY_BACKUPS_PATH}});const v={jsonrpc:"2.0",method:"initialize",params:{protocolVersion:"2024-11-05",capabilities:{tools:{}},clientInfo:{name:"mcp-memory-dashboard",version:"0.1.0"}},id:1};return console.log("Sending MCP initialize request:",v),g.stdin.write(JSON.stringify(v)+`
`),new Promise((I,T)=>{let S="",O=!1,N=!1;const B={jsonrpc:"2.0",method:"tools/call",params:{name:r,arguments:s},id:2};g.stdout.on("data",E=>{const R=E.toString();console.log("Raw MCP server response:",R),S+=R;const $=S.split(`
`);for(let p=0;p<$.length-1;p++){const o=$[p].trim();if(!(!o||N))try{const i=JSON.parse(o);if(console.log("Parsed MCP response:",i),i.jsonrpc==="2.0"&&typeof i.id<"u"){if(i.id===1&&!O){if(i.error){console.error("MCP initialization failed:",i.error),T(new Error(i.error.message||JSON.stringify(i.error))),g.kill();return}console.log("MCP initialization successful:",i.result),O=!0;const d={jsonrpc:"2.0",method:"notifications/initialized"};console.log("Sending initialized notification:",d),g.stdin.write(JSON.stringify(d)+`
`),console.log("Sending tool request:",B),g.stdin.write(JSON.stringify(B)+`
`);continue}if(i.id===2&&O){N=!0,i.error?(console.error("MCP tool call failed:",i.error),T(new Error(i.error.message||JSON.stringify(i.error)))):(console.log("MCP tool call successful:",i.result),I(i.result)),g.kill();return}}}catch{console.log("Non-JSON line (probably diagnostic):",o)}}S=$[$.length-1]}),g.stderr.on("data",E=>{console.error("MCP server stderr:",E.toString())}),g.on("error",E=>{console.error("Failed to start MCP server:",E),T(new Error(`Failed to start MCP server: ${E.message}`))}),g.on("exit",(E,R)=>{E!==0&&E!==null&&(console.error(`MCP server exited with code ${E}, signal ${R}`),T(new Error(`MCP server exited with code ${E}`)))}),setTimeout(()=>{N||(console.error("MCP server request timed out after 60 seconds"),console.error("Init complete:",O),console.error("Final accumulated response:",S),g.kill(),T(new Error("MCP server request timed out")))},6e4)})}catch(n){throw console.error("Error handling MCP tool request:",n instanceof Error?n.message:n),n}});u.app.whenReady().then(()=>{console.log("App is ready, creating window..."),C&&(C.setupIpcHandlers(),console.log("‚úÖ Direct ChromaDB IPC handlers initialized")),q()});u.app.on("window-all-closed",async()=>{if(console.log("All windows closed"),C){console.log("üßπ Cleaning up Direct ChromaDB Handler...");try{await C.cleanup(),console.log("‚úÖ Direct ChromaDB cleanup completed")}catch(a){console.error("‚ùå Error during DirectChromaHandler cleanup:",a)}}process.platform!=="darwin"&&u.app.quit()});u.app.on("before-quit",async a=>{if(console.log("App is about to quit, cleaning up resources..."),C){a.preventDefault(),console.log("üßπ Performing cleanup before quit...");try{await C.cleanup(),console.log("‚úÖ Cleanup completed, quitting app"),u.app.quit()}catch(e){console.error("‚ùå Error during cleanup:",e),u.app.quit()}}});u.app.on("activate",()=>{console.log("App activated"),u.BrowserWindow.getAllWindows().length===0&&q()});const de=u.app.requestSingleInstanceLock();de?u.app.on("second-instance",()=>{const a=u.BrowserWindow.getAllWindows()[0];a&&(a.isMinimized()&&a.restore(),a.focus())}):u.app.quit();
