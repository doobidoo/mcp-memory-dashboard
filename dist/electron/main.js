"use strict";var K=Object.defineProperty;var j=(a,e,t)=>e in a?K(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t;var k=(a,e,t)=>j(a,typeof e!="symbol"?e+"":e,t);const d=require("electron"),A=require("path"),P=require("fs"),W=require("os"),J=require("crypto"),G=require("http"),Q=require("https"),X=require("url"),q=require("util"),Z=require("child_process");function ee(a){return a&&a.__esModule&&Object.prototype.hasOwnProperty.call(a,"default")?a.default:a}var D={exports:{}};const te="16.5.0",oe={version:te};var F;function re(){if(F)return D.exports;F=1;const a=P,e=A,t=W,o=J,r=oe.version,c=/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;function l(n){const i={};let u=n.toString();u=u.replace(/\r\n?/mg,`
`);let f;for(;(f=c.exec(u))!=null;){const _=f[1];let h=f[2]||"";h=h.trim();const m=h[0];h=h.replace(/^(['"`])([\s\S]*)\1$/mg,"$2"),m==='"'&&(h=h.replace(/\\n/g,`
`),h=h.replace(/\\r/g,"\r")),i[_]=h}return i}function y(n){const i=S(n),u=p.configDotenv({path:i});if(!u.parsed){const m=new Error(`MISSING_DATA: Cannot parse ${i} for an unknown reason`);throw m.code="MISSING_DATA",m}const f=I(n).split(","),_=f.length;let h;for(let m=0;m<_;m++)try{const w=f[m].trim(),M=T(u,w);h=p.decrypt(M.ciphertext,M.key);break}catch(w){if(m+1>=_)throw w}return p.parse(h)}function g(n){console.log(`[dotenv@${r}][WARN] ${n}`)}function v(n){console.log(`[dotenv@${r}][DEBUG] ${n}`)}function I(n){return n&&n.DOTENV_KEY&&n.DOTENV_KEY.length>0?n.DOTENV_KEY:process.env.DOTENV_KEY&&process.env.DOTENV_KEY.length>0?process.env.DOTENV_KEY:""}function T(n,i){let u;try{u=new URL(i)}catch(w){if(w.code==="ERR_INVALID_URL"){const M=new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");throw M.code="INVALID_DOTENV_KEY",M}throw w}const f=u.password;if(!f){const w=new Error("INVALID_DOTENV_KEY: Missing key part");throw w.code="INVALID_DOTENV_KEY",w}const _=u.searchParams.get("environment");if(!_){const w=new Error("INVALID_DOTENV_KEY: Missing environment part");throw w.code="INVALID_DOTENV_KEY",w}const h=`DOTENV_VAULT_${_.toUpperCase()}`,m=n.parsed[h];if(!m){const w=new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${h} in your .env.vault file.`);throw w.code="NOT_FOUND_DOTENV_ENVIRONMENT",w}return{ciphertext:m,key:f}}function S(n){let i=null;if(n&&n.path&&n.path.length>0)if(Array.isArray(n.path))for(const u of n.path)a.existsSync(u)&&(i=u.endsWith(".vault")?u:`${u}.vault`);else i=n.path.endsWith(".vault")?n.path:`${n.path}.vault`;else i=e.resolve(process.cwd(),".env.vault");return a.existsSync(i)?i:null}function O(n){return n[0]==="~"?e.join(t.homedir(),n.slice(1)):n}function N(n){!!(n&&n.debug)&&v("Loading env from encrypted .env.vault");const u=p._parseVault(n);let f=process.env;return n&&n.processEnv!=null&&(f=n.processEnv),p.populate(f,u,n),{parsed:u}}function B(n){const i=e.resolve(process.cwd(),".env");let u="utf8";const f=!!(n&&n.debug);n&&n.encoding?u=n.encoding:f&&v("No encoding is specified. UTF-8 is used by default");let _=[i];if(n&&n.path)if(!Array.isArray(n.path))_=[O(n.path)];else{_=[];for(const M of n.path)_.push(O(M))}let h;const m={};for(const M of _)try{const H=p.parse(a.readFileSync(M,{encoding:u}));p.populate(m,H,n)}catch(H){f&&v(`Failed to load ${M} ${H.message}`),h=H}let w=process.env;return n&&n.processEnv!=null&&(w=n.processEnv),p.populate(w,m,n),h?{parsed:m,error:h}:{parsed:m}}function E(n){if(I(n).length===0)return p.configDotenv(n);const i=S(n);return i?p._configVault(n):(g(`You set DOTENV_KEY but you are missing a .env.vault file at ${i}. Did you forget to build it?`),p.configDotenv(n))}function R(n,i){const u=Buffer.from(i.slice(-64),"hex");let f=Buffer.from(n,"base64");const _=f.subarray(0,12),h=f.subarray(-16);f=f.subarray(12,-16);try{const m=o.createDecipheriv("aes-256-gcm",u,_);return m.setAuthTag(h),`${m.update(f)}${m.final()}`}catch(m){const w=m instanceof RangeError,M=m.message==="Invalid key length",H=m.message==="Unsupported state or unable to authenticate data";if(w||M){const V=new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");throw V.code="INVALID_DOTENV_KEY",V}else if(H){const V=new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");throw V.code="DECRYPTION_FAILED",V}else throw m}}function $(n,i,u={}){const f=!!(u&&u.debug),_=!!(u&&u.override);if(typeof i!="object"){const h=new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");throw h.code="OBJECT_REQUIRED",h}for(const h of Object.keys(i))Object.prototype.hasOwnProperty.call(n,h)?(_===!0&&(n[h]=i[h]),f&&v(_===!0?`"${h}" is already defined and WAS overwritten`:`"${h}" is already defined and was NOT overwritten`)):n[h]=i[h]}const p={configDotenv:B,_configVault:N,_parseVault:y,config:E,decrypt:R,parse:l,populate:$};return D.exports.configDotenv=p.configDotenv,D.exports._configVault=p._configVault,D.exports._parseVault=p._parseVault,D.exports.config=p.config,D.exports.decrypt=p.decrypt,D.exports.parse=p.parse,D.exports.populate=p.populate,D.exports=p,D.exports}var ne=re();const ae=ee(ne);async function se(a,e=3e4){const t=Date.now();for(;Date.now()-t<e;){try{if(P.existsSync(a)){const o=P.readFileSync(a,"utf-8");if(o.trim())return console.log(`File found: ${a}, content: ${o.trim()}`),o}}catch(o){console.log(`Error reading file ${a}:`,o)}await new Promise(o=>setTimeout(o,500))}throw new Error(`File ${a} not found or empty after ${e}ms`)}async function ie(a){return new Promise(e=>{try{const s=(new X.URL(a).protocol==="https:"?Q:G).get(a,r=>{console.log(`Server check: ${a} responded with status ${r.statusCode}`),e(r.statusCode!==void 0&&r.statusCode<500),s.destroy()});s.on("error",r=>{console.log(`Server check error for ${a}:`,r.message),e(!1),s.destroy()}),s.setTimeout(5e3,()=>{console.log(`Server check timeout for ${a}`),e(!1),s.destroy()})}catch(t){console.log(`Server check failed for ${a}:`,t),e(!1)}})}function Y(){console.log("üîß Starting createWindow()...");const a=process.env.NODE_ENV==="development"?A.join(process.cwd(),"dist/electron/preload.js"):A.join(__dirname,"preload.js");console.log("üìÑ Preload script path:",a),console.log("üìÇ Preload file exists:",require("fs").existsSync(a));const e=new d.BrowserWindow({width:1200,height:800,title:"Memory Dashboard",webPreferences:{nodeIntegration:!1,contextIsolation:!0,preload:a,webSecurity:!0,sandbox:!0,webgl:!1,additionalArguments:[`--memory-service-path=${process.env.VITE_MEMORY_SERVICE_PATH}`,`--memory-chroma-path=${process.env.VITE_MEMORY_CHROMA_PATH}`,`--memory-backups-path=${process.env.VITE_MEMORY_BACKUPS_PATH}`,`--claude-config-path=${process.env.VITE_CLAUDE_CONFIG_PATH}`]}});if(console.log("ü™ü BrowserWindow created successfully"),console.log("Environment variables:",{VITE_MEMORY_SERVICE_PATH:process.env.VITE_MEMORY_SERVICE_PATH,VITE_MEMORY_CHROMA_PATH:process.env.VITE_MEMORY_CHROMA_PATH,VITE_MEMORY_BACKUPS_PATH:process.env.VITE_MEMORY_BACKUPS_PATH,VITE_CLAUDE_CONFIG_PATH:process.env.VITE_CLAUDE_CONFIG_PATH,MCP_MEMORY_CHROMA_PATH:process.env.MCP_MEMORY_CHROMA_PATH,MCP_MEMORY_BACKUPS_PATH:process.env.MCP_MEMORY_BACKUPS_PATH}),e.webContents.on("did-fail-load",(t,o,s)=>{console.error("Failed to load page:",s),e.reload()}),e.webContents.on("render-process-gone",(t,o)=>{console.error("Render process gone:",o.reason),o.reason==="crashed"&&(e.destroy(),Y())}),e.webContents.on("did-finish-load",async()=>{console.log("Window finished loading"),await(async(s=3)=>{for(let r=0;r<s;r++)try{console.log(`Attempt ${r+1} to connect to memory service...`);const c=await e.webContents.executeJavaScript(`
            if (window.electronAPI && window.electronAPI.memory) {
              const health = await window.electronAPI.memory.check_database_health();
              console.log('Memory service health:', health);
              return health;
            } else {
              throw new Error('Memory API not available');
            }
          `);return console.log("Memory service connection successful:",c),!0}catch(c){console.error(`Memory service connection attempt ${r+1} failed:`,c),await new Promise(l=>setTimeout(l,2e3))}return!1})()||(console.error("Failed to connect to memory service after multiple attempts"),e.webContents.send("memory-service-error","Failed to connect to memory service"))}),process.env.NODE_ENV==="development")console.log("Running in development mode"),setTimeout(async()=>{try{const o=A.join(process.cwd(),".vite-port");console.log("Looking for port file at:",o);const r=`http://localhost:${(await se(o)).trim()}`;if(console.log("Development server URL:",r),!await(async(y=5)=>{for(;y>0;){try{if(console.log(`Attempting to connect to ${r} (${y} retries left)`),await ie(r))return console.log("Successfully connected to development server"),!0}catch(g){console.log("Connection attempt failed:",g)}await new Promise(g=>setTimeout(g,1e3)),y--}return!1})())throw new Error("Failed to connect to development server after 5 attempts");console.log("Loading URL in window:",r),await e.loadURL(r)}catch(o){const s=o instanceof Error?o:new Error(String(o));console.error("Development server connection error:",s),e.isDestroyed()||e.webContents.send("dev-server-error",s.message),d.app.quit()}},1e3);else{console.log("Running in production mode");const t=A.join(__dirname,"../index.html");console.log("Loading file:",t),e.loadFile(t)}e.on("closed",()=>{console.log("Window closed"),e.destroy()}),e.webContents.on("before-input-event",(t,o)=>{o.control&&o.shift&&o.key.toLowerCase()==="i"&&e.webContents.toggleDevTools(),o.key==="F12"&&e.webContents.toggleDevTools()})}const b=q.promisify(Z.exec);class ce{constructor(e){k(this,"config");k(this,"containerProcess",null);k(this,"healthCheckInterval",null);k(this,"isShuttingDown",!1);this.config={containerName:"mcp-memory-chromadb",port:8e3,fallbackPort:8001,...e},console.log("üê≥ DockerChromaManager initialized:",this.config)}async isDockerAvailable(){try{return console.log("üîç Checking Docker availability..."),await b("docker --version"),await b("docker info"),console.log("‚úÖ Docker is available and running"),!0}catch(e){return console.log("‚ùå Docker not available:",e instanceof Error?e.message:"Unknown error"),!1}}async isPortAvailable(e){try{const{stdout:t}=await b(`lsof -i :${e}`);return console.log(`‚ö†Ô∏è Port ${e} is in use:`,t.trim()),!1}catch{return console.log(`‚úÖ Port ${e} is available`),!0}}async findAvailablePort(){const e=[this.config.port,this.config.fallbackPort||8001,8002,8003,8004];for(const t of e)if(await this.isPortAvailable(t))return t;throw new Error(`No available ports found. Tried: ${e.join(", ")}`)}async getContainerStatus(){try{const{stdout:e}=await b(`docker ps --filter "name=${this.config.containerName}" --format "{{.ID}},{{.Status}},{{.Ports}}"`);if(!e.trim())return console.log(`üìã Container ${this.config.containerName} is not running`),{running:!1,healthy:!1,port:this.config.port};const[t,o,s]=e.trim().split(","),r=s.match(/0\.0\.0\.0:(\d+)->/),c=r?parseInt(r[1]):this.config.port,l=o.includes("healthy")||!o.includes("unhealthy");return console.log(`‚úÖ Container ${this.config.containerName} is running on port ${c}`),{running:!0,healthy:l,port:c,containerId:t.trim()}}catch(e){return console.log("‚ùå Error checking container status:",e instanceof Error?e.message:"Unknown error"),{running:!1,healthy:!1,port:this.config.port,error:e instanceof Error?e.message:"Unknown error"}}}async cleanupExistingContainer(){try{console.log(`üßπ Cleaning up existing container: ${this.config.containerName}`);try{await b(`docker stop ${this.config.containerName}`),console.log("‚úÖ Container stopped")}catch{console.log("‚ÑπÔ∏è Container was not running or already stopped")}try{await b(`docker rm ${this.config.containerName}`),console.log("‚úÖ Container removed")}catch{console.log("‚ÑπÔ∏è Container was not found or already removed")}}catch(e){console.log("‚ö†Ô∏è Error during cleanup:",e instanceof Error?e.message:"Unknown error")}}validateChromaPath(){try{console.log(`üîç Validating ChromaDB path: ${this.config.chromaPath}`),P.existsSync(this.config.chromaPath)||(console.log("üìÅ ChromaDB directory does not exist, creating..."),P.mkdirSync(this.config.chromaPath,{recursive:!0}));const e=A.join(this.config.chromaPath,".docker-test");return P.writeFileSync(e,"test"),P.unlinkSync(e),console.log("‚úÖ ChromaDB path is valid and writable"),!0}catch(e){return console.error("‚ùå ChromaDB path validation failed:",e),!1}}async startContainer(){try{if(console.log("üöÄ Starting ChromaDB Docker container..."),!await this.isDockerAvailable())throw new Error("Docker is not available. Please install Docker Desktop and ensure it is running.");if(!this.validateChromaPath())throw new Error(`ChromaDB path is not accessible: ${this.config.chromaPath}`);const e=await this.findAvailablePort();e!==this.config.port&&console.log(`‚ö†Ô∏è Using fallback port ${e} instead of ${this.config.port}`),await this.cleanupExistingContainer();const o=["run","-d","--name",this.config.containerName,"-p",`${e}:8000`,"-v",`${this.config.chromaPath}:/chroma/chroma`,"--health-cmd",'sh -c "curl -f http://localhost:8000/api/v1/heartbeat || exit 1"',"--health-interval","10s","--health-timeout","5s","--health-retries","3","chromadb/chroma"].map(r=>r.includes(" ")&&!r.startsWith('"')?`"${r.replace(/"/g,'\\"')}"`:r).join(" ");console.log("üê≥ Docker command:",`docker ${o}`);const{stdout:s}=await b(`docker ${o}`);return console.log(`‚úÖ Container started with ID: ${s.trim()}`),await this.waitForContainerHealthy(e),this.startHealthMonitoring(e),{running:!0,healthy:!0,port:e,containerId:s.trim()}}catch(e){throw console.error("‚ùå Failed to start ChromaDB container:",e),e}}async waitForContainerHealthy(e,t=3e4){console.log(`‚è≥ Waiting for ChromaDB container to be healthy on port ${e}...`);const o=Date.now(),s=2e3;for(;Date.now()-o<t;){try{const{stdout:r}=await b(`docker inspect --format='{{.State.Health.Status}}' ${this.config.containerName}`),c=r.trim();if(c==="healthy"){console.log("‚úÖ Container is healthy and ready");return}console.log(`‚è≥ Container health status: ${c}, waiting...`);try{await b(`curl -f http://localhost:${e}/api/v1/heartbeat`),console.log("‚úÖ ChromaDB API is responding");return}catch{}}catch{console.log("‚è≥ Still waiting for container health check...")}await new Promise(r=>setTimeout(r,s))}throw new Error(`Container failed to become healthy within ${t}ms`)}startHealthMonitoring(e){console.log("üîÑ Starting health monitoring..."),this.healthCheckInterval=setInterval(async()=>{if(!this.isShuttingDown)try{const t=await this.getContainerStatus();(!t.running||!t.healthy)&&(console.warn("‚ö†Ô∏è ChromaDB container is not healthy, attempting restart..."),await this.restartContainer())}catch(t){console.error("‚ùå Health check failed:",t)}},3e4)}async restartContainer(){console.log("üîÑ Restarting ChromaDB container...");try{return await b(`docker restart ${this.config.containerName}`),await this.waitForContainerHealthy(this.config.port),console.log("‚úÖ Container restarted successfully"),await this.getContainerStatus()}catch(e){return console.error("‚ùå Failed to restart container:",e),await this.startContainer()}}async stopContainer(){console.log("üõë Stopping ChromaDB container..."),this.isShuttingDown=!0,this.healthCheckInterval&&(clearInterval(this.healthCheckInterval),this.healthCheckInterval=null);try{(await this.getContainerStatus()).running?(await b(`docker stop ${this.config.containerName}`),console.log("‚úÖ Container stopped successfully")):console.log("‚ÑπÔ∏è Container was not running")}catch(e){console.log("‚ö†Ô∏è Error stopping container:",e instanceof Error?e.message:"Unknown error")}}async getChromaApiUrl(){return`http://localhost:${(await this.getContainerStatus()).port}`}async testConnection(){try{const e=await this.getChromaApiUrl();return await b(`curl -f ${e}/api/v1/heartbeat`),console.log(`‚úÖ ChromaDB API connection successful: ${e}`),!0}catch(e){return console.log("‚ùå ChromaDB API connection failed:",e instanceof Error?e.message:"Unknown error"),!1}}async cleanup(){console.log("üßπ Cleaning up Docker ChromaDB Manager..."),await this.stopContainer()}}class le{constructor(e){k(this,"config");k(this,"client",null);k(this,"collection",null);k(this,"isInitialized",!1);k(this,"dockerManager",null);k(this,"useDockerMode",!0);k(this,"fallbackToMcp",!1);this.config=e,console.log("DirectChromaHandler initialized with config:",e),this.dockerManager=new ce({chromaPath:e.chromaPath,backupsPath:e.backupsPath,containerName:"mcp-memory-chromadb",port:8e3})}setupIpcHandlers(){console.log("Setting up direct ChromaDB IPC handlers..."),d.ipcMain.handle("direct-chroma:store",async(e,{content:t,metadata:o})=>await this.storeMemory(t,o)),d.ipcMain.handle("direct-chroma:retrieve",async(e,{query:t,n_results:o})=>await this.retrieveMemory(t,o)),d.ipcMain.handle("direct-chroma:search-by-tag",async(e,{tags:t})=>await this.searchByTag(t)),d.ipcMain.handle("direct-chroma:delete-by-tag",async(e,{tag:t})=>await this.deleteByTag(t)),d.ipcMain.handle("direct-chroma:get-stats",async(e,{})=>await this.getStats()),d.ipcMain.handle("direct-chroma:check-health",async(e,{})=>await this.checkHealth()),d.ipcMain.handle("direct-chroma:optimize",async(e,{})=>await this.optimizeDatabase()),d.ipcMain.handle("direct-chroma:backup",async(e,{})=>await this.createBackup()),d.ipcMain.handle("direct-chroma:status",async(e,{})=>await this.getStatusInfo())}async handleDirectRequest(e,t){switch(console.log(`Direct request: ${e}`,t),e){case"direct-chroma:store":return await this.storeMemory(t.content,t.metadata);case"direct-chroma:retrieve":return await this.retrieveMemory(t.query,t.n_results);case"direct-chroma:search-by-tag":return await this.searchByTag(t.tags);case"direct-chroma:delete-by-tag":return await this.deleteByTag(t.tag);case"direct-chroma:get-stats":return await this.getStats();case"direct-chroma:check-health":return await this.checkHealth();case"direct-chroma:optimize":return await this.optimizeDatabase();case"direct-chroma:backup":return await this.createBackup();case"direct-chroma:status":return await this.getStatusInfo();default:throw new Error(`Unknown operation: ${e}`)}}async initializeClient(){if(!this.isInitialized)try{if(console.log("üöÄ Initializing ChromaDB with Docker container..."),!this.dockerManager)throw new Error("Docker manager not initialized");if(!await this.dockerManager.isDockerAvailable())throw console.log("‚ö†Ô∏è Docker not available, falling back to MCP approach"),this.fallbackToMcp=!0,new Error("Docker ChromaDB fallback: Docker not available, using stable MCP service approach");let t=await this.dockerManager.getContainerStatus();if(t.running?console.log(`‚úÖ ChromaDB container already running on port ${t.port}`):(console.log("üê≥ Starting ChromaDB Docker container..."),t=await this.dockerManager.startContainer()),!await this.dockerManager.testConnection())throw new Error("Failed to connect to ChromaDB container");const{ChromaApi:s}=require("chromadb"),r=await this.dockerManager.getChromaApiUrl();console.log(`üîó Connecting to ChromaDB at: ${r}`),this.client=new s({path:r});try{this.collection=await this.client.getCollection({name:"memories"}),console.log("‚úÖ Using existing memories collection")}catch{console.log("üìÅ Creating new memories collection..."),this.collection=await this.client.createCollection({name:"memories",metadata:{description:"MCP Memory Dashboard storage",created:new Date().toISOString()}}),console.log("‚úÖ Memories collection created")}this.isInitialized=!0,console.log("üéâ Direct ChromaDB access initialized successfully!")}catch(e){console.error("‚ùå Direct ChromaDB initialization failed:",e),this.fallbackToMcp=!0;const t=e instanceof Error?e.message:"Unknown error";throw new Error(`üîß Direct ChromaDB Access Failed: ${t}. Falling back to stable MCP service approach. To resolve: ensure Docker Desktop is installed and running, then restart the application.`)}}async storeMemory(e,t){await this.initializeClient();try{const o=`memory_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,s={...t,timestamp:new Date().toISOString(),type:(t==null?void 0:t.type)||"memory"};return await this.collection.add({ids:[o],documents:[e],metadatas:[s]}),console.log(`‚úÖ Memory stored successfully: ${o}`),{success:!0,id:o,content_hash:o,message:"Memory stored successfully"}}catch(o){throw console.error("‚ùå Error storing memory:",o),new Error(`Failed to store memory: ${o instanceof Error?o.message:"Unknown error"}`)}}async retrieveMemory(e,t=5){await this.initializeClient();try{console.log(`üîç Retrieving memories for query: "${e}" (n=${t})`);const o=await this.collection.query({queryTexts:[e],nResults:t}),s=[];if(o.ids&&o.ids[0])for(let c=0;c<o.ids[0].length;c++){const l={id:o.ids[0][c],content:o.documents[0][c],metadata:o.metadatas[0][c]||{},distance:o.distances?o.distances[0][c]:void 0};s.push(l)}return console.log(`‚úÖ Retrieved ${s.length} memories`),{memories:s,query_text:e,n_results:t}}catch(o){throw console.error("‚ùå Error retrieving memories:",o),new Error(`Failed to retrieve memories: ${o instanceof Error?o.message:"Unknown error"}`)}}async searchByTag(e){await this.initializeClient();try{console.log(`üè∑Ô∏è Searching by tags: ${e.join(", ")}`);const t=await this.collection.get({include:["documents","metadatas"]}),o=[];if(t.ids)for(let r=0;r<t.ids.length;r++){const c=t.metadatas[r]||{},l=c.tags||[];if(e.some(g=>Array.isArray(l)?l.includes(g):typeof l=="string"?l.split(",").map(v=>v.trim()).includes(g):!1)){const g={id:t.ids[r],content:t.documents[r],metadata:c};o.push(g)}}return console.log(`‚úÖ Found ${o.length} memories with matching tags`),{memories:o,search_tags:e}}catch(t){throw console.error("‚ùå Error searching by tags:",t),new Error(`Failed to search by tags: ${t instanceof Error?t.message:"Unknown error"}`)}}async deleteByTag(e){await this.initializeClient();try{console.log(`üóëÔ∏è Deleting memories with tag: ${e}`);const t=await this.collection.get({include:["metadatas"]}),o=[];if(t.ids)for(let r=0;r<t.ids.length;r++){const l=(t.metadatas[r]||{}).tags||[];(Array.isArray(l)?l.includes(e):typeof l=="string"?l.split(",").map(g=>g.trim()).includes(e):!1)&&o.push(t.ids[r])}return o.length>0&&await this.collection.delete({ids:o}),console.log(`‚úÖ Deleted ${o.length} memories with tag: ${e}`),{success:!0,deleted_count:o.length,deleted_ids:o,message:`Successfully deleted ${o.length} memories with tag: ${e}`}}catch(t){throw console.error("‚ùå Error deleting by tag:",t),new Error(`Failed to delete by tag: ${t instanceof Error?t.message:"Unknown error"}`)}}async getStats(){await this.initializeClient();try{console.log("üìä Getting database statistics...");const e=await this.collection.get({include:["metadatas"]}),t=e.ids?e.ids.length:0,o=new Set;if(e.metadatas)for(const c of e.metadatas)c&&c.tags&&(Array.isArray(c.tags)?c.tags:typeof c.tags=="string"?c.tags.split(",").map(y=>y.trim()):[]).forEach(y=>{y&&y.trim()&&o.add(y.trim())});const s=o.size;return console.log(`‚úÖ Stats: ${t} memories, ${s} unique tags`),{total_memories:t,unique_tags:s,collection_name:this.collection.name}}catch(e){return console.error("‚ùå Error getting stats:",e),{total_memories:0,unique_tags:0,collection_name:"unknown"}}}async checkHealth(){try{console.log("üè• Checking database health...");const e=Date.now();await this.initializeClient();const t=await this.collection.get({limit:1}),o=Date.now()-e;return console.log(`‚úÖ Health check passed (${o}ms)`),{health:1,avg_query_time:o,status:"healthy",database_path:this.config.chromaPath,collection_ready:!!this.collection}}catch(e){return console.error("‚ùå Health check failed:",e),{health:0,avg_query_time:0,status:"error",error:e instanceof Error?e.message:"Unknown error"}}}async optimizeDatabase(){await this.initializeClient();try{console.log("‚ö° Optimizing database...");const e=Date.now(),t=await this.getStats(),o=Date.now()-e;return console.log(`‚úÖ Database optimization completed (${o}ms)`),{success:!0,optimization_time_ms:o,memories_count:t.total_memories,unique_tags:t.unique_tags,message:"Database optimization completed successfully",details:{database_path:this.config.chromaPath,collection_name:this.collection.name}}}catch(e){throw console.error("‚ùå Error optimizing database:",e),new Error(`Database optimization failed: ${e instanceof Error?e.message:"Unknown error"}`)}}async createBackup(){await this.initializeClient();try{console.log("üíæ Creating database backup...");const e=Date.now(),o=`backup_${new Date().toISOString().replace(/[:.]/g,"-")}`,s=A.join(this.config.backupsPath,o);P.mkdirSync(s,{recursive:!0});const r=await this.collection.get({include:["documents","metadatas"]}),c={metadata:{created:new Date().toISOString(),source_path:this.config.chromaPath,collection_name:this.collection.name,total_memories:r.ids?r.ids.length:0},memories:[]};if(r.ids)for(let v=0;v<r.ids.length;v++)c.memories.push({id:r.ids[v],content:r.documents[v],metadata:r.metadatas[v]||{}});const l=A.join(s,"memories_backup.json");P.writeFileSync(l,JSON.stringify(c,null,2));const y=Date.now()-e;return console.log(`‚úÖ Backup created successfully: ${o} (${y}ms)`),{success:!0,backup_name:o,backup_path:s,backup_file:l,memories_count:c.memories.length,backup_time_ms:y,message:`Backup created successfully with ${c.memories.length} memories`}}catch(e){throw console.error("‚ùå Error creating backup:",e),new Error(`Backup creation failed: ${e instanceof Error?e.message:"Unknown error"}`)}}async cleanup(){console.log("üßπ Cleaning up DirectChromaHandler..."),this.dockerManager&&await this.dockerManager.cleanup(),this.client=null,this.collection=null,this.isInitialized=!1}isUsingDockerMode(){return this.useDockerMode&&!this.fallbackToMcp}async getStatusInfo(){try{if(this.dockerManager&&!this.fallbackToMcp){const e=await this.dockerManager.getContainerStatus(),t=await this.dockerManager.getChromaApiUrl();return{mode:"docker",docker_available:await this.dockerManager.isDockerAvailable(),container_running:e.running,container_healthy:e.healthy,api_url:t,port:e.port,database_path:this.config.chromaPath}}return{mode:"mcp_fallback",fallback_reason:this.fallbackToMcp?"Docker unavailable or failed":"Not initialized",database_path:this.config.chromaPath}}catch(e){return{mode:"error",error:e instanceof Error?e.message:"Unknown error"}}}}console.log("üîß Starting main process...");const L=A.join(process.cwd(),".env");console.log("Loading environment variables from:",L);const x=ae.config({path:L});x.error?console.error("Error loading .env file:",x.error):(console.log("Environment variables loaded successfully"),process.env.MCP_MEMORY_CHROMA_PATH=process.env.VITE_MEMORY_CHROMA_PATH,process.env.MCP_MEMORY_BACKUPS_PATH=process.env.VITE_MEMORY_BACKUPS_PATH,console.log("Set MCP environment variables:",{MCP_MEMORY_CHROMA_PATH:process.env.MCP_MEMORY_CHROMA_PATH,MCP_MEMORY_BACKUPS_PATH:process.env.MCP_MEMORY_BACKUPS_PATH}));console.log("üéØ App initialization complete, waiting for ready event...");let C=null;const U=process.env.VITE_USE_DIRECT_CHROMA_ACCESS==="true";console.log("Direct ChromaDB access enabled:",U);if(U){const a=process.env.VITE_MEMORY_CHROMA_PATH||process.env.MCP_MEMORY_CHROMA_PATH,e=process.env.VITE_MEMORY_BACKUPS_PATH||process.env.MCP_MEMORY_BACKUPS_PATH;a&&e?(C=new le({chromaPath:a,backupsPath:e}),console.log("‚úÖ Initialized Direct ChromaDB Handler - Eliminates MCP service duplication")):console.warn("‚ö†Ô∏è  Direct ChromaDB access requested but paths not configured")}console.log("üîß Setting up app event handlers...");d.app.on("will-quit",a=>{console.log("‚ö†Ô∏è App will-quit event triggered")});console.log("üîß Setting up window-all-closed handler...");d.app.isReady()?console.log("üéâ App was already ready!"):console.log("‚è≥ App not ready yet, waiting...");process.on("uncaughtException",a=>{console.error("üö® Uncaught Exception:",a)});process.on("unhandledRejection",(a,e)=>{console.error("üö® Unhandled Rejection at:",e,"reason:",a)});d.app.on("ready",()=>{console.log("üéä App ready event fired!")});console.log("üîí Requesting single instance lock...");const he=d.app.requestSingleInstanceLock();he?(console.log("‚úÖ Got single instance lock"),d.app.on("second-instance",()=>{console.log("üîÑ Second instance detected");const a=d.BrowserWindow.getAllWindows()[0];a&&(a.isMinimized()&&a.restore(),a.focus())})):(console.log("‚ùå Failed to get single instance lock, quitting..."),d.app.quit());d.app.disableHardwareAcceleration();d.app.commandLine.appendSwitch("disable-software-rasterizer");d.app.commandLine.appendSwitch("disable-gpu");d.app.commandLine.appendSwitch("disable-gpu-compositing");d.app.commandLine.appendSwitch("disable-gpu-sandbox");const de=q.promisify(P.readFile),ue=q.promisify(P.exists);d.ipcMain.handle("fs:readFile",async(a,{path:e,options:t})=>{try{return console.log("Main process reading file:",e),await de(e,t)}catch(o){throw console.error("Main process readFile error:",o),o}});d.ipcMain.handle("fs:exists",async(a,{path:e})=>{try{return console.log("Main process checking file exists:",e),await ue(e)}catch(t){return console.error("Main process exists error:",t),!1}});d.ipcMain.handle("mcp:use-tool",async(a,e)=>{const{server_name:t,tool_name:o,arguments:s}=e;if(console.log(`Handling MCP tool request: ${t}/${o}`,{args:s,useDirectAccess:U}),U&&C&&t==="memory"){console.log("üöÄ Using Direct ChromaDB Access - No MCP service spawning");try{switch(o){case"store_memory":return await C.handleDirectRequest("direct-chroma:store",s);case"dashboard_retrieve_memory":case"retrieve_memory":return await C.handleDirectRequest("direct-chroma:retrieve",s);case"dashboard_search_by_tag":case"search_by_tag":return await C.handleDirectRequest("direct-chroma:search-by-tag",s);case"delete_by_tag":return await C.handleDirectRequest("direct-chroma:delete-by-tag",s);case"dashboard_get_stats":case"get_stats":return await C.handleDirectRequest("direct-chroma:get-stats",s);case"dashboard_check_health":case"check_database_health":return await C.handleDirectRequest("direct-chroma:check-health",s);case"dashboard_optimize_db":case"optimize_db":return await C.handleDirectRequest("direct-chroma:optimize",s);case"dashboard_create_backup":case"create_backup":return await C.handleDirectRequest("direct-chroma:backup",s);default:throw new Error(`Unsupported tool: ${o}`)}}catch(r){console.error("Direct ChromaDB access error, falling back to MCP:",r)}}console.log("‚ö†Ô∏è  Using MCP service spawning approach");try{const r=process.env.VITE_CLAUDE_CONFIG_PATH;if(!r)throw new Error(`VITE_CLAUDE_CONFIG_PATH environment variable not set. Available env vars: ${Object.keys(process.env).filter(I=>I.startsWith("VITE_")).join(", ")}`);console.log("Reading MCP config from:",r);const c=JSON.parse(P.readFileSync(r,"utf-8"));console.log("Available MCP servers:",Object.keys(c.mcpServers));const l=c.mcpServers[t];if(!l)throw new Error(`MCP server "${t}" not found in configuration. Available servers: ${Object.keys(c.mcpServers).join(", ")}`);const{spawn:y}=require("child_process");console.log("Spawning MCP server process:",{command:l.command,args:l.args,cwd:process.env.VITE_MEMORY_SERVICE_PATH,env:Object.keys({...process.env,...l.env})});const g=y(l.command,l.args,{env:{...process.env,...l.env,PYTHONPATH:process.env.VITE_MEMORY_SERVICE_PATH,MCP_MEMORY_CHROMA_PATH:process.env.MCP_MEMORY_CHROMA_PATH||process.env.VITE_MEMORY_CHROMA_PATH,MCP_MEMORY_BACKUPS_PATH:process.env.MCP_MEMORY_BACKUPS_PATH||process.env.VITE_MEMORY_BACKUPS_PATH},cwd:process.env.VITE_MEMORY_SERVICE_PATH,stdio:["pipe","pipe","pipe"]});console.log("MCP server process spawned with:",{pid:g.pid,command:l.command,args:l.args,cwd:process.env.VITE_MEMORY_SERVICE_PATH,env:{PYTHONPATH:process.env.VITE_MEMORY_SERVICE_PATH,MCP_MEMORY_CHROMA_PATH:process.env.MCP_MEMORY_CHROMA_PATH||process.env.VITE_MEMORY_CHROMA_PATH,MCP_MEMORY_BACKUPS_PATH:process.env.MCP_MEMORY_BACKUPS_PATH||process.env.VITE_MEMORY_BACKUPS_PATH}});const v={jsonrpc:"2.0",method:"initialize",params:{protocolVersion:"2024-11-05",capabilities:{tools:{}},clientInfo:{name:"mcp-memory-dashboard",version:"0.1.0"}},id:1};return console.log("Sending MCP initialize request:",v),g.stdin.write(JSON.stringify(v)+`
`),new Promise((I,T)=>{let S="",O=!1,N=!1;const B={jsonrpc:"2.0",method:"tools/call",params:{name:o,arguments:s},id:2};g.stdout.on("data",E=>{const R=E.toString();console.log("Raw MCP server response:",R),S+=R;const $=S.split(`
`);for(let p=0;p<$.length-1;p++){const n=$[p].trim();if(!(!n||N))try{const i=JSON.parse(n);if(console.log("Parsed MCP response:",i),i.jsonrpc==="2.0"&&typeof i.id<"u"){if(i.id===1&&!O){if(i.error){console.error("MCP initialization failed:",i.error),T(new Error(i.error.message||JSON.stringify(i.error))),g.kill();return}console.log("MCP initialization successful:",i.result),O=!0;const u={jsonrpc:"2.0",method:"notifications/initialized"};console.log("Sending initialized notification:",u),g.stdin.write(JSON.stringify(u)+`
`),console.log("Sending tool request:",B),g.stdin.write(JSON.stringify(B)+`
`);continue}if(i.id===2&&O){N=!0,i.error?(console.error("MCP tool call failed:",i.error),T(new Error(i.error.message||JSON.stringify(i.error)))):(console.log("MCP tool call successful:",i.result),I(i.result)),g.kill();return}}}catch{console.log("Non-JSON line (probably diagnostic):",n)}}S=$[$.length-1]}),g.stderr.on("data",E=>{console.error("MCP server stderr:",E.toString())}),g.on("error",E=>{console.error("Failed to start MCP server:",E),T(new Error(`Failed to start MCP server: ${E.message}`))}),g.on("exit",(E,R)=>{E!==0&&E!==null&&(console.error(`MCP server exited with code ${E}, signal ${R}`),T(new Error(`MCP server exited with code ${E}`)))}),setTimeout(()=>{N||(console.error("MCP server request timed out after 60 seconds"),console.error("Init complete:",O),console.error("Final accumulated response:",S),g.kill(),T(new Error("MCP server request timed out")))},6e4)})}catch(r){throw console.error("Error handling MCP tool request:",r instanceof Error?r.message:r),r}});d.app.whenReady().then(()=>{console.log("üéâ App is ready, creating window..."),C&&(C.setupIpcHandlers(),console.log("‚úÖ Direct ChromaDB IPC handlers initialized")),console.log("üì± Calling createWindow()..."),Y(),console.log("‚úÖ createWindow() completed")}).catch(a=>{console.error("‚ùå Error in app.whenReady():",a)});d.app.on("window-all-closed",async()=>{if(console.log("All windows closed"),C){console.log("üßπ Cleaning up Direct ChromaDB Handler...");try{await C.cleanup(),console.log("‚úÖ Direct ChromaDB cleanup completed")}catch(a){console.error("‚ùå Error during DirectChromaHandler cleanup:",a)}}process.platform!=="darwin"&&d.app.quit()});let z=!1;d.app.on("before-quit",async a=>{if(console.log("App is about to quit, cleaning up resources..."),z){console.log("üîÑ Already quitting, allowing immediate exit");return}if(C){a.preventDefault(),z=!0,console.log("üßπ Performing cleanup before quit...");try{await C.cleanup(),console.log("‚úÖ Cleanup completed, quitting app")}catch(e){console.error("‚ùå Error during cleanup:",e)}finally{d.app.quit()}}});d.app.on("activate",()=>{console.log("App activated"),d.BrowserWindow.getAllWindows().length===0&&Y()});
